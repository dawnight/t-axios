# 1. 处理 URL

+ 处理 URL 会有几种需要特殊处理的情况
+ 参数值为数组，如果参数是 `fruits: ['apple', 'banana']`，那么需要转化成为 `fruits[]=apple&fruits[]=banana`
+ 参数值为对象，如果参数是 `user: { name: 'mark' }`，那么需要转化成为 `user=%7B%22name%22:%22mark%22%7D`
+ 参数值为 Date，如果参数是 `time: new Date()`，那么需要转化成为 `time=2019-06-17T14:30:46.406Z`
+ 特殊字符，这些 `@`, `:`, `$`, `,`, ` `, `[`, `]` 字符可以出现在 URL 中，其他的字符则要被转义
+ 如果值为 null 或 undefined，那么不会被添加到 URL 中
+ 丢弃 URL 中的哈希标记
+ 保留 URL 中已经存在的参数

# 2. 为什么要处理 URL

+ 如果不做处理，可能会造成实际传输的数据与我们预想的数据或数据格式不一致
+ URL 对字符有限制，不是所有的字符都可以直接传输，针对特殊字符，需要 encode 转义
+ 有一些字符是 URL 里的特殊字符，比如 `&`，`=`，`?`，`#` 等，这些在 URL 里有特殊含义，但是我们如果还想再 URL 传递带有这几个字符的参数，那么就需要对这几个参数做转义
+ 处理哈希是因为服务端是不识别哈希符号的，假如 `name` 的值是 `#mark`，如果我们在 URL 里这样写 `http://localhost:3000/user?name=#mark`，那么实际上传输的 URL 是 `http://localhost:3000/user?name=`，这样是错误的，所以我们要对 `#` 符号转义，或者直接剪掉哈希符号后边的内容。
+ 保留 URL 里已经存在的参数是因为，如果我们的 URL 是这样的 `http://localhost:3000/user?id=100&id=200`，那么实际上服务端接收到的 id 参数的值是 `100: [100, 200]`，这是符合 HTTP 规范的，所以我们不能让后边的数据把前边的数据覆盖掉，所以要保留

# 3. 判断纯对象 isPlainObject

+ 首先确认一个问题，什么是纯对象
+ 不同的库在验证纯对象的时候，方法不一样，而且有很大的不一样，所以在使用的时候，可以采取下边的某一种判断方法

+ [vue 里判断纯对象的方法](https://github.com/vuejs/vue/blob/dev/src/shared/util.js)

```javascript
function isPlainObject(value) {
  return Object.prototype.toString.call(value) === '[object Object]';
}
```

+ [redux 里判断纯对象的方法](https://github.com/reduxjs/redux/blob/master/src/utils/isPlainObject.js)

```javascript
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) {
    return false;
  }

  let proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}
```

+ [lodash 里判断纯对象的方法](https://github.com/lodash/lodash/blob/master/isPlainObject.js)

```javascript
const toString = Object.prototype.toString;

function isObjectLike(value) {
  return typeof value == 'object' && value !== null;
}

function getTag(value) {
  if (value == null) {
    return value === undefined ? '[object Undefined]' : '[object Null]';
  }
  return toString.call(value);
}

function isPlainObject(value) {
  if (!isObjectLike(value) || getTag(value) != '[object Object]') {
    return false;
  }
  if (Object.getPrototypeOf(value) === null) {
    return true;
  }
  let proto = value;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value) === proto;
}
```

+ [is-plain-object 库判断纯对象的方法](https://github.com/jonschlinkert/is-plain-object/blob/master/index.js)

```javascript
import isObject from 'isobject';

function isObjectObject(o) {
  return isObject(o) === true
    && Object.prototype.toString.call(o) === '[object Object]';
}

export default function isPlainObject(o) {
  var ctor,prot;

  if (isObjectObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (typeof ctor !== 'function') return false;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObjectObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
};
```

# 4. axios 的基本逻辑处理

+ axios 是一个方法，可以直接调用，通过传递不同的参数，请求类型，获取到不同的值
+ axios 在内部会对 URL 和传递的参数做相应的处理
+ axios 在请求数据时会有一个 request 的信息，里边包含请求的 URL，Method，data，params，headers，responseType，timeout
+ axios 在响应数据时也有一个 response 的信息，里边包含响应的 data，status，statusText，headers，requestConfig，request
+ axios 在请求错误的时候会有一个 error 的信息，里边包含请求 requestConfig，code，request，response，isAxiosError
+ axios 是一个 Promise，需要把方法包装成 Promise

# 5. axios request 的处理

+ request 接口

```typescript
export interface AxiosRequestConfig {
  url: string;
  method?: Method;
  data?: any;
  params?: any;
  headers?: any;
  responseType?: XMLHttpRequestResponseType;
  timeout?: number;
}
```

+ 请求方法示例

```javascript
axios.get('/user', {
  params: {
    id: 100
  },
  timeout: 10000,
  headers: {
    'content-type': 'application/json;charset=utf-8'
  },
  responseType: 'json'
});
```

+ 第 1， 所有的数据信息都在 config 对象里
+ 第 2， 处理 URL，通过我们的 buildURL 方法
+ 第 3， 处理请求头信息
  + 比如 headers 里的 `content-type` 没有设置，要默认添加 `content-type`
  + 如果 headers 里写了 `content-type`，但是写的是小写，我们要转换成大写 `Content-Type`
+ 第 4， 处理 data 信息，如果 data 是纯对象，那么就直接转成字符串
+ 第 5， 处理完数据之后，把处理后的 config 作为 xhr 的参数传递，在 xhr 方法中根据需要，设置对应的数据，发送请求

# 6. axios response 和 error 的处理

+ response 的接口

```typescript
export interface AxiosResponse<T = any> {
  data: T;
  status: number;
  statusText: string;
  headers: any;
  config: AxiosRequestConfig;
  request: any;
}
```

+ 第 1， 响应对象里必须包含 data， status， statusText， headers， config， request 信息
+ 第 2， 处理响应数据，如果数据能够 JSON 序列化，那么就转成 JSON，如果不能，就直接返回
+ 第 3， 处理响应头信息，由于 XMLHttpRequest 返回的响应头是一个字符串，我们要把响应头解析成 JSON 对象
+ 第 4， 如果配置了响应类型，那么就应该返回响应类型的数据，默认是 json 类型
+ 第 5， 如果数据返回正常，那么直接 resolve 响应数据
+ 第 6， 如果发生错误，包括 ontimeout，onerror 和其他错误，返回对应的错误信息，配置信息，错误码，请求对象，响应对象
